# Email Spoofing
**Boston University EC700 Epoch2 Project:** 

**Authors: Pujan Paudel and Apollo Lo**

Emails are one of the most common ways of communication between people using electronic devices. It uses a specific protocol called SMTP (Simple Mail Transfer Protocol) to transmit messages between servers and the receiving server has a three-step verification process that authenticates the identity of the sender before passing the email to the receiver. In our project, our aim is to identify and conduct vulnerability analysis of these email protocols and how it can lead to email spoofing

Email spoofing is the technique of creating forged email addresses when sending an email. The purpose is for an attacker to impersonate a legitimate company/person and trick the receiver of the email. The use of email spoofing varies from spreading misinformation to spreading malware and stealing private data from the user.

## Email Flow

<div align="center"><a href="url"><img src="https://github.com/apollolo/Email-Spoofing/blob/main/pictures/Email%20flow.PNG" align="center"></a>
  
  *Source: Composition Kills: A Case Study of Email Sender Authentication on https://www.usenix.org/system/files/sec20-chen-jianjun.pdf*</div>

### SMTP (Simple Mail Transfer Protocol)
SMTP, defined in [RFC5321](https://tools.ietf.org/html/rfc5321), is the most commonly used protocol to transmit emails between two users. When user A wants to send an email to another user B, user A will first draft up the email in MUA(Mail User Agent), which is the application users interact with. The email will be transmitted to the Sending service via SMTP protocol on port 25 or 587, which will then be transmitted to the Receiving server using SMTP again. When sending with SMTP, the client will send an EHLO command to identify itself with the domain name. Then it will send "MAIL FROM" and "RCPT TO'' to identify the sender and receiver for the email. Each command will have an OK reply code from the server as the response. The next command is the data command, which indicates the start of the email message contents. These message contents are the contents that show up to users in their MUA. After the message has been crafted and sent to the server, the quit command is sent to indicate the end of the conversation.

### MIME (Multipurpose Internet Mail Extension)
MIME is an extension of the email message content sent through SMTP. It allows messages to be sent in different languages and attach files or videos in the email, which could not be done by SMTP. According to [RFC4021](https://tools.ietf.org/html/rfc4021), there are multiple headers that are defined by MIME, however, our project will focus on from header, sender header, To header, and subject header as these are the headers a user will typically see in their email.

## Authentication 
Since there is no authentication mechanism in SMTP, the receiving server will have implemented its own authentication methods to combat forged email addresses. Users typically rely on the email server to filter out forged emails or separate spam emails from legitimate emails. SPF, DKIM, and DMARC are the three most widely adopted protocols for email authentication. These three protocols are combined together to verify different parts of an email and ensure email authenticity.

### SPF (Sender Policy Framework)
[RFC 7208](https://tools.ietf.org/html/rfc7208) stated that since there are no restrictions on what can be placed in the EHLO command and "MAIL FROM" in the SMTP protocol, SPF will verify if the email is indeed sent from these domains. The receiving mail server will query the domain from "MAIL FROM" for SPF record, which is a DNS record that was added to the domain by the sending mail server. The SPF record will specify which IP address or hostnames are authorized to send email on their behalf. SPF will have different policies for different scenarios. If the email IP address doesn't match the IP address from the SPF record, then a "fail" result is given, otherwise a "pass" result for matching IP address. "Permerror" result shows up when SPF could not verify the domain, either by missing "MAIL FROM" or a non-existing domain name.

### DKIM (DomainKeys Identified Mail)
DKIM is an authentication mechanism that attaches a digital signature to the email. The idea is that the sender of the email will create hashes of the different message headers to ensure data integrity. DKIM includes “d tag” for the domain and “s tag” for a "selector", the selector is used to identify which DKIM signature amongst multiple signatures in the same domain. The receiver of the email will query "{s tag}r.\_domainkey{d tag}" for the public key and use it to ensure that the headers that are encrypted are not modified. The architecture of DKIM is defined in [RFC 6376](https://tools.ietf.org/html/rfc6376)

### DMARC (Domain-based Message Authentication, Reporting and Conformance)
DMARC is the last step of the authentication process and depends on the results from the previous two which is explained in [RFC7489](https://tools.ietf.org/html/rfc7489). The receiver will conduct an alignment test of the domain in "from header" with domains in DKIM and SPF. It will query the domain in "from header" in the data message for DMARC records published by the sender. The sender will specify what to do with emails that failed SPF and DKIM, which the receiver will follow. This ensures that no other brand can pretend to be the sender, and if the receiver got an email that pretends to be a company, the receiver will notify the company with the information in DMARC record. 

## Threat Model
Our method is to identify potential vulnerabilities in the email process flow. The first step is to understand how these authentication protocols work. SPF verifies if the email is sent from an authorized IP address and  DKIM makes sure the content of the email isn’t modified by attaching a digital signature. DMARC conducts alignment tests on domain names, which will ensure that the sender of the email, the author of the digital signature, and the identity of the sender shown to the email receiver are all the same. 
The next step is to identify what is shown to the user, and how a user might be spoofed. We know that email contents in the DATA command sent in SMTP is what is shown to the user. So the “from header”, which is the one that DMARC verifies, becomes our main target. Our project goal is to act as the attacker, and create a spoofed email that can pass all the authentication process and still shows up as a legitimate company to the user in the email.

## Method
For discovering potential vulnerabilities on different Email systems, we need to design a black-box testing mechanism. We know the authentication mechanisms the email providers are using, but since these systems are proprietary systems, we don’t have access to the source code of how they implement the details of the authentication processes. Since there are many fields/cases within the RFCs of the protocols such as SPF, DKIM which don’t enforce concrete implementations of protocols at various granularities, there might exist irregularities between the implementations of the protocol. The idea for searching for vulnerabilities is to perform black-box testing on the email providers trying to break the system when subjected to edge cases/irregularities on the implementation of the protocols. 
We started by creating python scripts that connected to the SMTP server of the email providers such as Gmail, which required establishing a TLS connection. It allowed us to send emails normally with expected behavior, without manipulation of email headers like adding extra addresses on the From field. It also didn’t allow changing the SMTP Mailfrom address and other customization we had planned for the attack. Hence, we had to create our custom email server to have the capability of customizing our headers and what we send to the email providers. We utilized the domain name of one of the members of the project, Pujan called pujanpaudel.net. For hosting our email server, we searched through different hosting providers such as Google Cloud. We discovered that Google cloud blocks outbound port 25, which would make sending outgoing emails not possible. We found that the hosting provider, Digital ocean doesn’t block outbound port 25. We hosted our email server on Digitalocean. We utilized an open-source email server called Postal for our study purposes. Postal was fully customizable and modular which served our purpose. We built the Postal server making changes on how we want to modify the default headers and fields such as EHLO, SMTP Mailfrom , DKIM d header, DKIM s header. We also configured the server so that we can have our own custom rules on the email signature generation pipeline. Since our black box testing required us to send a large number of emails with different variations on the headers; we created an API for the postal server to allow us to automate the sending process. After the email was sent and received by the email providers, we created a Selenium program that opens the mailbox of our target email address, infers where the email landed ( main Inbox, or Junk mailbox ), and also stores the details of the headers as received by the mail provider.


### Testing Phase
We wanted to test if there can be misalignment from DMARC when there are multiple versions of the same header. We tried directly sending multiple headers from our email server to see if there are any abnormal behaviors. When sending multiple “smtp from”, and mail “from header”, the receiving server accepted our email but it never appeared in our receiving email inbox. Normally when an email fails an authentication protocol, these emails will appear in the spam folder. It appears that these receiving servers don't process our email if the email contains multiple headers. We also sent multiple “d tag” in DKIM through injections, where the second tag is merged inside the first header. For example, if normal emails sent d=”domain.com”, we sent d=”pujanpaudel.com; d=facebook.com”. The injection method could be sent successfully but the email ends up in the receiver’s spam folder. Our reasoning for this attack is that we want DKIM to query a “d tag” while DMARC verifies another “d tag”. This way DKIM will still pass when it query’s the attacker’s domain while DMARC will pass when aligning spoofed “from header” with the wrong “d tag”. This method unfortunately failed, and we did not find a solution that can cause misalignment. It appears that the receiving server we tested also query the same DKIM “d tag”.
The next testing method is to inject different versions of the Unicode. Since SMTP supports Unicode, it is possible that the authentication process recognizes the encoded Unicode and query those domains, which it shows up as decoded characters in the UI side. This type of attack is similar to a homograph attack, where we want the authentication system of the receiving server to see one thing. But human users see a different thing. We also want Unicode to cause the authentication process to fail to verify without giving a failed result. Some email servers have a more relaxed protocol, so if one of the authentication processes failed to verify, but no fail result, the email could still pass and be sent to the user's inbox.

### Challenges 
During our experiments, we faced multiple challenges from the email provider side of things. After trying out multiple header variations on the From header, our email server was initially rate-limited, and eventually blocked by Gmail servers. Yahoo servers also put our server on a blacklist at the very first attempt of sending multiple headers. It might also have to do with the age of the account as we had created a fresh account for the project purposes. Zoho mail; after a few iterations of sending emails; blocked our server’s IP address as we tried sending multiple from headers. Eventually, Office 365 and Protonmail were the only email servers that didn’t block us or kept us under any rate limit. Hence we proceeded with our evaluations with those two email providers.

## Results
Out of the plethora of attack variations we tried, on sending multiple From headers with different Unicode characters, multiple selectors, and domain identifiers on DKIM signature, there were two combinations of attack strings where it was able to fool the email providers and the email appeared at the normal mailbox section. In our experiments, we attempt to impersonate security@facebook.com. 
 In the case of ProtonMail, we discovered that when we send the From headers as 
From: security@facebook.com"+<unicode>+ "(info@pujanpaudel.net) 
where <unicode> refers to a subset of Unicode characters that are successful in breaking the user interface of the Protonmail email provider.  When inspecting the headers of the email, we found that the email passed all three of the SPF, DKIM, and DMARC protocols by checking against the attacker-controlled domain (info@pujanpaudel.net), while displaying security@facebook.com as the sender. 
  
<div align="center"><a href="url"><img src="https://github.com/apollolo/Email-Spoofing/blob/main/pictures/Proton%20result.PNG" align="center"></a>
*Figure: Successful Spoofing attack on Protonmail.*</div>

Similarly, in the case of Office 365, we discovered that when we send the From headers as 
From: security@facebook.com"+ <unicode>+" ,<info@pujanpaudel.net>
where <unicode> refers to a subset of Unicode characters that are successful in breaking the user interface of the Protonmail email provider. The SPF, DKIM, and DMARC protocols pass by checking the domain under our control, displaying security@facebook.com as the sender. 
 <div align="center"><a href="url"><img src="https://github.com/apollolo/Email-Spoofing/blob/main/pictures/Outlook%20result.PNG" align="center"></a>
*Figure: Successful Spoofing attack on Office365.*</div>
  
We can notice that the attack payload is slightly different in the case of Protonmail, and Office 365. In the case of Office365, we are directly sending multiple From addresses while separating them with vulnerability invoking <unicode>. Whereas, in the case of Protonmail when we tried to repeat the same attack, the email was received by the Protonmail server, but it didn’t appear in the mailbox. It was probably filtered by the internal systems. Hence, a slight modification of attack payload in Protonmail creates a vulnerability, where we send effectively multiple headers on the From address, but only one address on the record by hiding the second email under the “(“ which is treated as comments under the RFC specifications of SMTP. 
In the third result we discovered, we found that there is a misconfiguration of how DMARC is interpreted by Office 365. When we sign our message by an unopened comment structure “ with no corresponding ( for a closing ) “.
message.dkim_domain("d=pujanpaudel.net);")
 We find that the DMARC results successfully pass despite the DKIM having a failure status. This shouldn’t be happening as DMARC should automatically fail when the DKIM signature fails to pass. But we discover that Office 365 allows the DMARC to pass under this scenario and the email appears under the normal mailbox. 


<div align="center"><a href="url"><img src="https://github.com/apollolo/Email-Spoofing/blob/main/pictures/Outlook%20DMARC.PNG" align="center"></a>
*Figure: DMARC misconfiguration for Office 365.*</div>

## Lessons learned
Email authentication is not perfect, despite having standardized protocols, as it is up to the email servers to set up email authentication correctly. The protocols such as DKIM, SPF, DMARC work in isolation without coordination with each other, which opens upon avenues on how either of the protocols could be fooled along the authentication chain. Most of the email providers take effective preventive measures such as blocking multiple headers, normalizing text sent under headers which didn’t allow some of the attacks we had envisioned to work properly. But the disconnected nature of the protocols among each other and non-strict specifications or multiple choices of implementations always poses a chance of vulnerabilities being present in the email sphere. 
Our project would have been more fruitful if we weren’t limited by the email servers we tested, and the number of emails we could test. Despite keeping timers between consecutive email sending, we were blocked from performing large-scale experiments which would be necessary to discover vulnerabilities, especially in the context of black-box testing. Since only two of the platforms didn’t limit us on testing the deformed headers, we couldn’t gather a comprehensive picture of other vulnerabilities which might have existed on the other email providers. Many email servers have anti-spam protocols that immediately blocked our IP address which hinders us from further testing. We could not verify whether or not their authentication is flawless, but at least they can successfully block repeated spam emails.
This project can also be extended further with forwarded emails, where there have been findings of vulnerabilities in DKIM signatures and their structure. The idea would be to resend emails with verified DKIM signatures which were not strictly signed based on RFC specifications and could potentially allow us to inject additional headers. One further potential extension could be to develop fuzzer that tries to break the interpretation of DKIM signatures. In our case, the use of unopened comments on domain identifiers created confusion on the DMARC header. This shows signs that the different tags on the DKIM signature could be exploited with proper characters to include new vulnerabilities. 
Our major takeaway from the project was, the approach to discovering email authentication vulnerabilities lies in identifying even the smallest header/field on the protocol specifications that are part of the email authentication process. It needn’t be the most important piece of the protocol or authentication process, but even the most unimportant or sometimes deemed an optional piece of the process can be a point of vulnerability. Once we discover those points of vulnerability, creating maximum chaos with a combination of characters, Unicode on those protocols always has a chance to lead us to find new vulnerabilities.

