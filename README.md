# Email Spoofing
**Boston University EC700 Epoch2 Project:** 

**Authors: Pujan Paudel and Apollo Lo**

Emails are the one of the most common ways of communication between people using electronic devices. It uses a specific protocol called SMTP (Simple Mail Transfer Protocol) to transmit messages between servers and the receiving server has a three step verification process that authenticates the identity of the sender before passing the email to the receiver. In our project, our aim is to identify and conduct vulnerability analysis of these email protocols and how it can lead to email spoofing

Email spoofing is the technique of creating forged email addresses when sending an email. The purpose is for an attacker to impersonate a legitimate company/person and trick the receiver of the email. The use of email spoofing varies from spreading misinformation, to spreading malware and stealing private data from the user.

## Email Flow

<div align="center"><a href="url"><img src="https://github.com/apollolo/Email-Spoofing/blob/main/pictures/Email%20flow.PNG" align="center"></a>
  
  *Source: Composition Kills: A Case Study of Email Sender Authentication on https://www.usenix.org/system/files/sec20-chen-jianjun.pdf*</div>

### SMTP (Simple Mail Transfer Protocol)
SMTP, defined in [RFC5321](https://tools.ietf.org/html/rfc5321), is the most common use of protocol to transmit emails between two users. When user A wants to send an email to another user B, user A will first draft up the email in MUA(Mail User Agent), which is the application users interact with. The email will be transmitted to the Sending service via SMTP protocol on port 25 or 587, which will then be transmitted to the Receiving server using SMTP again. When user B logs into his/her email account, the receiving server will transmit all emails received by the account to User B, which will show up on user B's MUA. 

During SMTP, the client will send with EHLO command to identify itself with the domain name. Then it will send "MAIL FROM" and "RCPT TO" to identify the sender and receiver for the email. Each command will have a OK reply code from the server as the respond. The next command is the data command, which indicates the start of the email message contents. These message contents are the contents that shows up to user in their MUA. After the message has been crafted and sent to the server, the quit command is sent to indicate the end of the conversation.

### MIME (Multipurpose Internet Mail Extension)
MIME is an extension of the email message content sent through SMTP. It allows messages to send in a different languages and attach files or videos in the email, which could not be done by SMTP. According to [RFC4021](https://tools.ietf.org/html/rfc4021), there are multiple headers that are defined by MIME, however our project will focus on from header, sender header, to header, and subject header as these are the headers a user will typically see in their email.

## Authentication 
Since there is no authentication mechanism in SMTP, the receiving server will have implemented its own authentication methods to combat forged email addresses. Users typically rely on the email server to filter out forged emails or separate spam emails from legitimate emails. SPF, DKIM, and DMARC are the three most widely adopted protocols for email authentication. These three protocols are combined together to verify different parts of an email and ensure email authenticity.

### SPF (Sender Policy Framework)
[RFC 7208](https://tools.ietf.org/html/rfc7208) stated that since there are no restrictions on what can be placed EHLO command and "MAIL FROM" in the SMTP protocol, SPF will verify if the email is indeed sent from these domains. receiving mail server will query the domain from "MAIL FROM" for SPF record, which is a DNS record that was added to the domain by the sending mail server. The SPF record will specify which IP address or hostnames are authorized to send email on their behalf. SPF will have different policies for different scenarios. If the email IP address doesn't match the IP address from SPF record, then a "fail" result is given, otherwise a "pass" result for matching IP address. "Permerror" result shows up when SPF could not verify the domain, either by missing "MAIL FROM" or non-existing domain name. 

### DKIM (DomainKeys Identified Mail)
DKIM is an authentication mechanism that attach a digital signature to the email. The idea is that sender of the email will create hashes of the different message headers to ensure data integrity. DKIM includes d tag for the domain and s tag for a "selector", selector is used to identify which DKIM signature amongst multiple signatures in the same domain. The receiver of the email will query "{s tag}r.\_domainkey{d tag}" for the public key and use it to ensure that the headers that are encrypted are not modified. 
The architecture of DKIM is defined in [RFC 6376](https://tools.ietf.org/html/rfc6376)

### DMARC (Domain-based Message Authentication, Reporting and Conformance)
DMARC is the last step of the authentication process and depends on the results from the previous two which is explained in [RFC7489](https://tools.ietf.org/html/rfc7489). The receiver will conduct alignment test of the domain in "from header" with domains in DKIM and SPF. It will query the domain in "from header" in the data message for DMARC record published by the sender. The sender will specify what to do with emails that failed SPF and DKIM, which the receiver will follow. This ensures that no other brand can pretend to be the sender, and if the receiver got an email that pretends to the be a company, the receiver will notify the company with information in DMARC record.  

## Threat Model
Our method is to identify potential vulnerabilities in the email process flow. The first step is to understand how these authentication protocols work. SPF verifies if the email is sent from an authorized IP address and  DKIM makes sure the content of the email isn’t modified by attaching a digital signature. DMARC conducts alignment tests on domain names, which will ensure that the sender of the email, the author of the digital signature, and the identity of the sender shown to the email receiver are all the same. 
The next step is to identify what is shown to the user, and how a user might be spoofed. We know that email contents in the DATA command sent in SMTP is what is shown to the user. So the “from header”, which is the one that DMARC verifies, becomes our main target. Our project goal is act as the attacker, and create a spoofed email that can pass all the authentication process and still shows up as a legitimate company to the user in the email. 

## Method
For discovering potential vulnerabilities on different Email systems, we need to design a black box testing  mechanism. We know what the authentication mechanisms the email providers are using, but since these systems are proprietary systems, we don’t have access to the source code of how they implement the details of the authentication processes. Since there are many fields / cases within the RFCs of the protocols  such as SPF, DKIM which don’t enforce concrete implementations of protocols at various granularities, there might exist irregularities between the implementations of the protocol. The idea for searching for vulnerabilities is to perform black box testing on the email providers trying to break the system when subjected under edge cases / irregularities on the implementation of the protocols. 
We started by creating python scripts that connected to the SMTP server of the email providers such as Gmail, which required establishing a TLS connection.It allowed us to send emails normally with expected behavior, without manipulation of email headers like adding extra addresses on the Form  field. It also didn’t allow changing the SMTP mailfrom address and other customization we had planned for the attack. Hence , we had to create our custom email server to have the capability of customizing our headers and what we send to the email providers. We utilized the domain name of one of the members of the project , Pujan called pujanpaudel.net. For hosting our email server, we searched through different hosting providers such as Google Cloud. We discovered that Google cloud blocks outbounding port 25 , which would make sending outgoing emails not possible. We found that the hosting provider, Digital ocean doesn’t block outbounding port 25. We hosted our email server on Digitalocean. We utilized an open source email server called Postal for our study purposes. Postal was fully customizable and modular which served our purpose. We built the postal server making changes on how we want to modify the default headers  and fields such as EHLO , SMTP Mailfrom , DKIM d header, DKIM s header. We also configured the server so that we can have our own custom rules on the email signature generation pipeline. Since our black box testing required us sending a large number of emails with different variations on the headers ; we created an API for the postal server to allow us to automate the sending process. After the email was sent and received by the email providers, we created a Selenium program that opens the mailbox of our target email address, infers where the email landed ( main Inbox , or Junk mailbox ) , and also stores the details of the headers as received  by the mail provider.

### Testing Phase
We wanted to test if there can be misalignment from DMARC when there are multiple versions of the same header. We tried directly sending multiple headers from our email server to see if there are any abnormal behaviors. When sending multiple “smtp from”, and mail “from header”, the receiving server accepted our email but it never appeared in our receiving email inbox. Normally when an email fails an authentication protocol, these emails will appear in the spam folder. It appears that these receiving servers don't process our email if the email contains multiple headers. We also sent multiple “d tag” in DKIM through injections, where the second tag is merged inside the first header. For example, if normal emails sent d=”domain.com”, we sent d=”pujanpaudel.com; d=facebook.com”. The injection method could be sent successfully but the email ends up in the receiver’s spam folder. Our reasoning for this attack is that we want DKIM to query a “d tag” while DMARC verifies another “d tag”. This way DKIM will still pass when it query’s the attacker’s domain while DMARC will pass when aligning spoofed “from header” with the wrong “d tag”. This method unfortunately failed, and we did not find a solution that can cause misalignment. It appears that the receiving server we tested also query the same DKIM “d tag”.
The next testing method is to inject different versions of the unicodes. Since SMTP supports unicodes, it is possible that the authentication process recognizes the encoded unicodes and query those domains, which it shows up as decoded characters in the UI side. This type of attack is similar to homograph attack, where we want the authentication system of the receiving server to see one thing. But human users see a different thing. We also want unicodes to cause the authentication process to fail to verify without giving a failed result. Some email servers have a more relaxed protocol, so if one of the authentication processes failed to verify, but no fail result, the email could still pass and be sent to the user's inbox.

### Challenges 
During our experiments, we faced multiple challenges from the email providers side of things. After trying out multiple header variations on the From header, our email server was initially rate limited, and eventually blocked by Gmail servers. Yahoo servers also put our server in a blacklist at the very first attempt of sending multiple headers. It might also have to do with the age of the account as we had created a fresh account for the project purposes. Zohomail; after a few iterations of sending emails; blocked our server’s IP address as we tried sending multiple from headers. Eventually , Office 365 and Protonmail were the only email servers that didn’t block us or kept us under any rate limit. Hence we proceeded with our evaluations with those two email providers.


## Results
Out of the plethora of attack variations we tried, on sending multiple From headers with different Unicode characters, multiple selectors and domain identifiers on DKIM signature , there were two combinations of attack strings where it was able to fool the email providers and the email appeared at the normal mailbox section. In our experiments, we attempt to impersonate security@facebook.com. 
In case of ProtonMail , we discovered that when we send the From headers as From: security@facebook.com"+<unicode>+ "(info@pujanpaudel.net) 
where <unicode> refers to a subset of unicode characters that are successful in breaking the user interface of the Protonmail email provider.  When inspecting the headers of the email , we found that the email passed all three of the SPF, DKIM , and DMARC protocols by checking  against the attacker controlled domain (info@pujanpaudel.net) , while displaying security@facebook.com as the sender. 
(image placement)

Similarly, in case of Office 365, we discovered that when we send the From headers as 
From: security@facebook.com"+ <unicode>+" ,<info@pujanpaudel.net>
where <unicode> refers to a subset of unicode characters that are successful in breaking the user interface of the Protonmail email provider. The SPF, DKIM , and DMARC protocols pass by checking the domain under our control , displaying security@facebook.com as the sender.
  
  We can notice that the attack payload is slightly different in case of Protonmail , and Office 365. In the case of Office365 , we are directly sending multiple  from addresses while separating them with vulnerability invoking <unicode>. Whereas, in the case of Protonmail when we tried to repeat the same attack, the email was received by the Protonmail server, but it didn’t appear in the mailbox. It was probably filtered by the internal systems. Hence , a slight modification of attack payload in Protonmail creates a vulnerability , where we send effectively multiple headers on the From address, but only one address on the record by hiding the second email under the “(“ which is treated as comments under the RFC specifications of SMTP. 
 
 (image placement)
In the third result we discovered , we  found that there is a misconfiguration of  how DMARC is interpreted by Office 365. When we sign our message by  an unopened comment structure “ with no corresponding ( for a closing ) “.
message.dkim_domain("d=pujanpaudel.net);")
 We find that the DMARC results successfully pass despite the DKIM having failure status. This shouldn’t be happening as DMARC should automatically fail when the DKIM signature fails to pass. But we discover that Office 365 allows the DMARC to pass under this scenario and the email appears under normal mailbox.

(image placement)
